# -*- coding: utf-8 -*-
"""Exercise_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fwlcyGpgqQetDishZPw8a-q_P7ZTYFtq
"""

# Giải bài tập _ Ngày 01/06/2024
# PHẦN TỰ LUẬN:

# Bài 1: Viết function thực hiện đánh giá classification model bằng F1-Score
# Viết hàm F1-Score
tp = int(input("Please input tp: "))
fp = int(input("Please input fp: "))
fn = int(input("Please input fn: "))

def f1_score_calc(tp, fp, fn):

# Kiểm tra kiểu dữ liệu của tp, fp, fn
  if not isinstance(tp, int):
    print(f"tp must be int, please input whole number for fp")
    return None
  if not isinstance(fp, int):
    print(f"fp must be int, please input whole number for fp")
    return None
  if not isinstance(fn, int):
    print(f"fn must be int, please input whole number for fn")
    return None

 # Kiểm tra giá trị của tp, fp, fn
  '''if (tp < 0) or (fp < 0) or (fn < 0):
    print(f"tp and fp and fn must be greater than zero")
    return None'''

  if not all(value > 0 for value in (tp, fp, fn)):
    print(f"tp and fp and fn must be greater than zero")
    return None

# Tính toán F1-Score
  precision =  tp / (tp + fp)
  recall = tp / (tp + fn)
  f1_score = 2 * (precision * recall) / (precision + recall)

  return precision, recall, f1_score

precision, recall, f1_score = f1_score_calc(tp, fp, fn)
print(f"Precision is {precision:.4f}; Recall is {recall:.4f}; F1-score is {f1_score:.4f}")

# Bài 2: Viết function mô phỏng theo 3 activation function
import math

# Hàm kiểm tra x
# Cách 1: Dùng try....except
def is_number(x):
  try:
    float(x)
    return True
  except ValueError:
    return False

'''# Cách 2: Dùng if...else
if is_number(x):
  print("x is a number")
else:
  print("x is not a number")

if isinstance(x, (int, float)):
  print("x is a number")
else:
  print("x is not a number")

# Cách 3: Dùng isinstance()
def is_number(x):
  return isinstance(x, (int, float, complex))

  # Cách 4: Dùng hàm abs()
if abs(x) > 0:
  print("x is a number")
else:
  print("x is not a number")'''

# Hàm kiểm tra tên activation function

def check_activation_function(activation_function, activation_function_list):
  if activation_function in activation_function_list:
      return True
  else:
      return False

# Hàm tính giá trị các hàm kích hoạt
def sigmoid(x):
  return 1 / (1 + math.exp(-x))

def relu(x):
  return max(0, x)

def elu(x):
  if x >= 0:
    return x
  else:
    return 0.01 * (math.exp(x) - 1) # Chọn alpha = 0.01

# Hàm chính để thực thi
def main():

# Nhập giá trị của x và tên activation function
  x = input("Please input x value: ")
  activation_function = input("Please input activation function name (signmoid | relu | elu): ")
  activation_function.lower()
  activation_function_list = ["sigmoid", "relu", "elu"]

# Kiểm tra x có hợp lệ hay không
  if not is_number(x):
    print("x must be a number")
    return
  else:
    x = float(x)

# Kiểm tra tên activation function
  if not check_activation_function(activation_function, activation_function_list):
    print("The activation function requested is not supported")

# Tính toán và trả về giá trị hàm
  if activation_function == "sigmoid":
    result = sigmoid(x)
  elif activation_function == "relu":
    result = relu(x)
  else:
    result = elu(x)

  return x, activation_function, result

# Gọi hàm main
x, activation_function, result = main()

# In kết quả
print(f"The result of {activation_function}({x}) is {result:.4f}")

# Bài 3: Viết function lựa chọn regression loss function để tính loss
import random
import math

# Định nghĩa hàm Loss
def mae(y_true, y_pred):
    return sum(abs(y_true[i] - y_pred[i]) for i in range(len(y_true))) / len(y_true)

def mse(y_true, y_pred):
    return sum((y_true[i] - y_pred[i]) ** 2 for i in range(len(y_true))) / len(y_true)

def rmse(y_true, y_pred):
    return math.sqrt(mse(y_true, y_pred))

# Viết hàm chính
def main():
    # Lấy số mẫu từ người dùng
    num_samples = input("Please input number of samples: ")

    if not num_samples.isnumeric():
        print("Number of samples must be an integer number")
        return

    num_samples = int(num_samples)

    # Lấy tên làm loss từ người dùng
    loss_name = input("Please input loss function name (MAE, MSE, RMSE) - Optional: ").upper()

    # Tạo mẫu dữ liệu bằng hàm random
    y_true = [random.uniform(0, 10) for _ in range(num_samples)]
    y_pred = [random.uniform(0, 10) for _ in range(num_samples)]

    # Tính hàm loss
    if loss_name == "MAE":
        loss = mae(y_true, y_pred)
    elif loss_name == "MSE":
        loss = mse(y_true, y_pred)
    elif loss_name == "RMSE":
        loss = rmse(y_true, y_pred)
    else:
        print("The loss function requested is not supported")
        return

    # Xuất kết quả
    print(f"Loss name: {loss_name}")
    for i in range(num_samples):
        print(f"Sample-{i}: predict = {y_pred[i]:.4f}, target = {y_true[i]:.4f}")
    print(f"Loss: {loss:.4f}")

# Gọi hàm main()
main()

# Bài 4: Viết 4 functions để ước lượng các hàm số sau
import math

# Viết 4 hàm định nghĩa sin, cos, sinh, cosh
def sin_function(x, n):
    result = 0
    for i in range(n):
        term = ((-1) ** i) * (x ** (2 * i + 1)) / math.factorial(2 * i + 1)
        result += term
    return result

def cos_function(x, n):
    result = 0
    for i in range(n):
        term = ((-1) ** i) * (x ** (2 * i)) / math.factorial(2 * i)
        result += term
    return result

def sinh_function(x, n):
    result = 0
    for i in range(n):
        term = (x ** (2 * i + 1)) / math.factorial(2 * i + 1)
        result += term
    return result

def cosh_function(x, n):
    result = 0
    for i in range(n):
        term = (x ** (2 * i)) / math.factorial(2 * i)
        result += term
    return result

# Triển khai
x = float(input("Type the value of x: "))
n = int(input("The the number of terms (n): "))

sin_approximate = sin_function(x, n)
cos_approximate = cos_function(x, n)
sinh_approximate = sinh_function(x, n)
cosh_approximate = cosh_function(x, n)

print(f"Estimate of sin({x}) with {n} terms: {sin_approximate:.4f}")
print(f"Estimate of cos({x}) with {n} terms: {cos_approximate:.4f}")
print(f"Estimate of sinh({x}) with {n} terms: {sinh_approximate:.4f}")
print(f"Estimate of cosh({x}) with {n} terms: {cosh_approximate:.4f}")

# Bài 5: Viết function thực hiện Mean Difference of nth Root Error
# Định nghĩa hàm mean_difference_nth_root_error (MD_nRE)
def mean_difference_nth_root_error(y, y_hat, n, p):
    if len(y) != len(y_hat):
        raise ValueError("The lengths of y and y_hat must be the same")

    m = len(y)
    total_error = 0

    for i in range(m):
        error = abs(y[i] - y_hat[i]) ** (p / n)
        total_error += error

    mean_error = total_error / m
    return mean_error

# Viết hàm main()
def main():
    try:
        y = list(map(float, input("Please input y (comma separated values): ").split(',')))
        y_hat = list(map(float, input("Please input y_hat (comma separated values): ").split(',')))
        n = int(input("Please input n (n is nth root): "))
        p = int(input("Please input p (p is degree of loss function): "))
    except ValueError as e:
        print(f"Invalid input: {e}")
        return

    if len(y) != len(y_hat):
        print("The lengths of y and y_hat must be the same")
        return

    result = mean_difference_nth_root_error(y, y_hat, n, p)
    print(f"Mean Difference of nth Root Error: {result:.4f}")

# Gọi hàm main()
main()

# PHẦN TRẮC NGHIỆM:
# Câu 1: Đáp án C
import math
def calc_f1_score( tp , fp , fn ):
# Your code here
    precision =  tp / (tp + fp)
    recall = tp / (tp + fn)
    f1_score = 2 * (precision * recall) / (precision + recall)

    return f1_score

# End your code
assert round(calc_f1_score ( tp = 2 , fp = 3 , fn = 5), 2) == 0.33
print(round(calc_f1_score ( tp = 2 , fp = 4 , fn = 5), 2))

# Câu 2: Đáp án B
import math
def is_number ( n ) :
# Your code here
    try:
        float(n)
        return True
    except ValueError:
        return False

# End your code
assert is_number (3) == True
assert is_number ("-2a") == False
print ( is_number (1) )
print ( is_number ("n") )

# Câu 3: Đáp án C
x = -2.0
if x <=0:
    y = 0.0
else :
    y = x
print ( y )

# Câu 4: Đáp án A
import math
def calc_sig ( x ) :
# Your code here
  return 1 / (1 + math.exp(-x))

# End your code
assert round ( calc_sig (3) , 2) == 0.95
print ( round ( calc_sig (2) , 2) )

# Câu 5: Đáp án B
import math

def calc_elu(x, alpha=0.01):
    if x <= 0:
        return alpha * (math.exp(x) - 1)
    else:
        return x

# Kiểm tra với các test cases
assert round(calc_elu(1)) == 1
print(round(calc_elu(-1), 2))

# Câu 6: Đáp án A
import math

def sigmoid(x):
    return 1 / (1 + math.exp(-x))

def relu(x):
    return max(0, x)

def elu(x, alpha=0.01):
    if x <= 0:
        return alpha * (math.exp(x) - 1)
    else:
        return x

def calc_activation_func(x, act_name):
    # Your code here
    if act_name == 'sigmoid':
        return sigmoid(x)
    elif act_name == 'relu':
        return relu(x)
    elif act_name == 'elu':
        return elu(x)
    else:
        raise ValueError(f"Unknown activation function: {act_name}")
    # End your code

# Kiểm tra với các test cases
assert calc_activation_func(x=1, act_name='relu') == 1
print(round(calc_activation_func(x=3, act_name='sigmoid'), 2))

# Câu 7: Đáp án A
def calc_ae(y, y_hat):
# Your code here
    return abs(y - y_hat)
# End your code

# Kiểm tra với các test cases
y = 1
y_hat = 6
assert calc_ae(y, y_hat) == 5

y = 2
y_hat = 9
print(calc_ae(y, y_hat))

# Câu 8: Đáp án A
def calc_se(y, y_hat):
# Your code here
    return (y - y_hat) ** 2
# End your code

# Kiểm tra với các test cases
y = 4
y_hat = 2
assert calc_se(y, y_hat) == 4

print(calc_se(2, 1))

# Câu 9: Đáp án C
import math

def approx_cos(x, n):
# Your code here
    cos_x = 0
    for i in range(n):
        term = ((-1) ** i) * (x ** (2 * i)) / math.factorial(2 * i)
        cos_x += term
    return cos_x
# End your code

# Kiểm tra với các test cases
assert round(approx_cos(x=1, n=10), 2) == 0.54
print(round(approx_cos(x=3.14, n=10), 2))  # Output: -1.00

# Câu 10: Đáp án A
import math

def approx_sin(x, n):
# Your code here
    sin_x = 0
    for i in range(n):
        term = ((-1) ** i) * (x ** (2 * i + 1)) / math.factorial(2 * i + 1)
        sin_x += term
    return sin_x
# End your code

# Kiểm tra với các test cases
assert round(approx_sin(x=1, n=10), 4) == 0.8415
print(round(approx_sin(x=3.14, n=10), 4))  # Output: 0.0016

# Câu 11: Đáp án A
import math

def approx_sinh(x, n):
# Your code here
    sinh_x = 0
    for i in range(n):
        term = (x ** (2 * i + 1)) / math.factorial(2 * i + 1)
        sinh_x += term
    return sinh_x
# End your code

# Kiểm tra với các test cases
assert round(approx_sinh(x=1, n=10), 2) == 1.18
print(round(approx_sinh(x=3.14, n=10), 2))  # Output: 11.53

# Câu 12: Đáp án A
import math

def approx_cosh(x, n):
# Your code here
    cosh_x = 0
    for i in range(n):
        term = (x ** (2 * i)) / math.factorial(2 * i)
        cosh_x += term
    return cosh_x
# End your code

# Kiểm tra với các test cases
assert round(approx_cosh(x=1, n=10), 2) == 1.54
print(round(approx_cosh(x=3.14, n=10), 2))  # Output: 11.29

# Câu 13: Đáp án D

def md_nre_single_sample3 (y , y_hat , n , p ) :
    y_root = y ** (1/ n )
    y_hat_root = y_hat ** (1/ n )
    difference = y_root - y_hat_root
    loss = difference
    return loss